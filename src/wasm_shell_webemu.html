<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>webemu</title>
    <meta name="viewport" content="width=device-width"/>
    <style>
     @keyframes blink {
         from {
             background-color: yellow;
         }
         to {
             background-color: transparent;
         }
     }

     .blinking {
         animation-name: blink;
         animation-duration: 600ms;
         animation-iteration-count: infinite;
         animation-direction: alternate;
     }

     .break {
         background-color: red !important;
     }
    </style>
  </head>
  <body style="font-family:monospace">
    <div style="position:sticky; left:0; top:0; background:lightblue; border-bottom:2px solid black; padding:8px">
      <input type="button" value="Load mem and program" id="prog_init" />
      Memory: <input type="text" size="3" id="mem_start" value="0x34" />--<input type="text" size="3" id="mem_end" value="0x40" /><input type="button" value="Set range" id="set_range" />
      <input type="button" value="Next clock (â†’)" id="clock" />
      <div style="background-color: yellow" id="err"></div>
    </div>

    <div style="display:flex">
      <div style="flex:1">
        <form>
          <textarea id="prog" rows="15" cols="20" placeholder="Program (assembly)"></textarea><br/>
          <textarea id="memfile" rows="15" cols="20" placeholder="Contents of .mem file"></textarea><br/>
        </form>
        <div>
          <a href="https://github.com/kofuk/exasm">View source code on GitHub</a>
        </div>
      </div>
      <div style="flex:2">
        <div id="status" style="background:lightgreen"></div>

        <div>
          Executed address: <input type="text" id="exec_addr" />
        </div>

        <div>
          Register:
          <table border="1">
            <thead>
              <tr>
                <th>r0</th>
                <th>r1</th>
                <th>r2</th>
                <th>r3</th>
                <th>r4</th>
                <th>r5</th>
                <th>r6</th>
                <th>r7</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><input type="text" size="3" id="reg0" /></td>
                <td><input type="text" size="3" id="reg1" /></td>
                <td><input type="text" size="3" id="reg2" /></td>
                <td><input type="text" size="3" id="reg3" /></td>
                <td><input type="text" size="3" id="reg4" /></td>
                <td><input type="text" size="3" id="reg5" /></td>
                <td><input type="text" size="3" id="reg6" /></td>
                <td><input type="text" size="3" id="reg7" /></td>
              </tr>
            </tbody>
          </table>
          <input type="button" value="Apply changes" id="apply_reg" />
        </div>

        <div>
          Memory:
          <table border="1">
            <thead>
              <tr>
                <th></th>
                <th>x0</th>
                <th>x1</th>
                <th>x2</th>
                <th>x3</th>
                <th>x4</th>
                <th>x5</th>
                <th>x6</th>
                <th>x7</th>
              </tr>
            </thead>
            <tbody id="mem_table_body">
            </tbody>
          </table>
          <input type="button" value="Apply changes" id="apply_mem" />
        </div>

        <div>
          Trace:
          <table border="1" style="display:block; max-height:350px; overflow: auto">
            <thead>
              <tr>
                <th>Break</th>
                <th>Instruction</th>
              </tr>
            </thead>
            <tbody id="trace_body"></tbody>
          </table>
        </div>
      </div>
    </div>

    <script>
     var Module = {
         preRun: [],
         postRun: [],
         print: function(text) {
             console.log(text);
         },
         printErr: function(text) {
             if (text.match(/^program exited/)) {
                 console.log(text);
                 return;
             }
             showError(text);
         },
         setStatus: function(text) {
             if (text) console.log(text);
         },
     };

     let emulator = 0;

     const showError = (text) => {
         document.getElementById('err').innerText = text;
     };

     const showStatus = (text) => {
         document.getElementById('status').innerText = text;
     };

     const updateEmulatorStatus = () => {
         if (emulator === 0) {
             return;
         }

         for (let i = 0; i < 8; i++) {
             const val = Module.ccall('get_register_value', 'number', ['number', 'number'],
                                      [emulator, i]);
             const el = document.getElementById('reg' + i);
             el.parentNode.classList.remove('blinking');
             if (parseInt(el.value) != val) {
                 el.parentNode.classList.add('blinking');
             }
             el.value = '0x' + val.toString(16);
         }
         const memOffset = Module.ccall('get_memory', 'number', ['number'], [emulator]);
         for (let i = memStart; i < memEnd; ++i) {
             const el = document.getElementById('mem' + i);
             el.parentNode.classList.remove('blinking');
             if (parseInt(el.value) != Module.HEAPU8[memOffset + i]) {
                 el.parentNode.classList.add('blinking');
             }
             el.value = '0x' + Module.HEAPU8[memOffset + i].toString(16);
         }
     };

     let memStart = 0;
     let memEnd = 0;

     const createMemTable = () => {
         let start = parseInt(document.getElementById('mem_start').value);
         let end = parseInt(document.getElementById('mem_end').value);
         if (isNaN(start) || isNaN(end) || (end < start)) {
             return;
         }
         start &= ~0x7;
         if ((end & 0x7) != 0) {
             end += 8 - end & 0x7;
         }

         document.getElementById('mem_start').value = '0x' + start.toString(16);
         document.getElementById('mem_end').value = '0x' + end.toString(16);

         if (start == memStart && end == memEnd) {
             return;
         }

         memStart = start;
         memEnd = end;

         const tableBody = document.getElementById('mem_table_body');
         tableBody.innerHTML = '';

         let tr;
         for (let i = start; i < end; ++i) {
             if (i % 8 == 0) {
                 tr = document.createElement('tr');
                 const td = document.createElement('td');
                 td.innerText = i.toString(16) + '-' + (i + 7).toString(16);
                 tr.appendChild(td);
             }
             const td = document.createElement('td');
             const input = document.createElement('input');
             input.type = 'text';
             input.size = 3;
             input.id = 'mem' + i;
             td.appendChild(input);
             tr.appendChild(td);

             if (i % 8 == 7) {
                 tableBody.appendChild(tr);
             }
         }
     };

     const blinkCurrentLine = (addr) => {
         const progLines = document.getElementById('trace_body').children;
         for (let i = 0; i < progLines.length; i++) {
             progLines[i].classList.remove('blinking', 'break');
         }
         const el = document.getElementById('prog' + addr);
         el.classList.add('blinking')
         el.scrollIntoView({
             behavior: 'smooth',
             block: 'nearest',
         });
     };

     const createTraceTable = () => {
         if (emulator === 0) {
             return;
         }

         const prog = Module.ccall('dump_program', 'string', ['number'],
                                   [emulator]);

         const traceBody = document.getElementById('trace_body');
         traceBody.innerHTML = '';
         let addr = 0;
         prog.split('\n')
             .forEach(e => {
                 if (e.length === 0) return;
                 const tr = document.createElement('tr');
                 tr.id = 'prog' + addr;
                 const td1 = document.createElement('td');
                 const checkBox = document.createElement('input');
                 checkBox.type = 'checkbox';
                 checkBox.id = 'break' + addr;
                 checkBox.addEventListener('change', e => {
                     const addr = parseInt(e.target.id.replace('break', ''));
                     if (isNaN(addr)) {
                         return;
                     }
                     if (e.target.checked) {
                         Module.ccall('set_breakpoint', 'number', ['number', 'number'],
                                      [emulator, addr]);
                     } else {
                         Module.ccall('remove_breakpoint', 'number', ['number', 'number'],
                                      [emulator, addr]);
                     }
                 });
                 td1.appendChild(checkBox);
                 tr.appendChild(td1);
                 const td2 = document.createElement('td');
                 td2.innerText = e;
                 tr.appendChild(td2);
                 traceBody.appendChild(tr);
                 addr += 2;
             });
     };

     const putStringToHeap = (str) => {
         const encoder = new TextEncoder();
         const data = encoder.encode(str);
         const offset = Module._malloc(data.length);
         for (let i = 0; i < data.length; i++) {
             Module.HEAPU8[i + offset] = data[i];
         }
         return [offset, data.length];
     };

     let breaked = false;

     const clock = () => {
         if (emulator === 0) {
             showError('Program not loaded');
             return;
         }

         showError('');

         const addr = Module.ccall('next_clock', 'number', ['number'], [emulator]);
         const breakAddr = Module.ccall('get_hit_breakpoint', 'number', [], []);
         if (breakAddr >= 0) {
             blinkCurrentLine(breakAddr);
             document.getElementById('break' + breakAddr).parentNode.parentNode
                     .classList.add('break');
             breaked = true;
             document.getElementById('clock').value = 'Continue';
         } else {
             blinkCurrentLine(addr);
             document.getElementById('exec_addr').value = '0x' + addr.toString(16);
         }

         updateEmulatorStatus();
     };

     addEventListener('load', () => {
         document.getElementById('prog_init')
                 .addEventListener('click', () => {
                     if (emulator !== 0) {
                         Module._free(emulator);
                         emulator = 0;
                     }

                     showError('');

                     const memdata = putStringToHeap(document.getElementById('memfile').value);
                     const progdata = putStringToHeap(document.getElementById('prog').value);

                     emulator = Module.ccall('init_emulator', 'number',
                                             ['number', 'number', 'number', 'numer'],
                                             [memdata[0], memdata[1], progdata[0], progdata[1]]);

                     Module._free(memdata[0]);
                     Module._free(progdata[0]);

                     createTraceTable();

                     showStatus('Ready');
                     updateEmulatorStatus();
                 });
         document.getElementById('set_range')
                 .addEventListener('click', () => {
                     createMemTable();
                     updateEmulatorStatus();
                 });
         document.getElementById('clock')
                 .addEventListener('click', e => {
                     breaked = false;
                     e.target.value = 'Next clock (â†’)';
                     clock();
                 });
         document.getElementById('apply_reg')
                 .addEventListener('click', () => {
                     if (emulator === 0) {
                         return;
                     }

                     for (let i = 0; i < 8; i++) {
                         const val = parseInt(document.getElementById('reg' + i).value);
                         if (isNaN(val)) {
                             continue;
                         }

                         Module.ccall('set_register_value', 'number',
                                      ['number', 'number', 'number'],
                                      [emulator, i, val]);
                     }
                     updateEmulatorStatus();
                 });
         document.getElementById('apply_mem')
                 .addEventListener('click', () => {
                     if (emulator === 0) {
                         return;
                     }

                     const dataTmp = Module._malloc(memEnd - memStart);
                     for (let i = 0; i < memEnd - memStart; i++) {
                         const val = parseInt(document.getElementById('mem' + (i + memStart)).value);
                         if (isNaN(val)) {
                             continue;
                         }

                         Module.HEAPU8[dataTmp + i] = val;
                     }

                     Module.ccall('set_mem_value', 'number',
                                  ['number', 'number', 'number', 'number'],
                                  [emulator, dataTmp, memEnd - memStart, memStart]);
                     Module._free(dataTmp);
                     updateEmulatorStatus();
                 });

         createMemTable();
     });

     document.body.addEventListener('keydown', e => {
         if (breaked) {
             return;
         }
         if (e.key === 'ArrowRight') {
             clock();
         }
     });
    </script>
    {{{ SCRIPT }}}
  </body>
</html>
